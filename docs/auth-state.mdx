# Authentication State Management

## Overview

This project implements a flexible authentication state management system that allows switching between React Context API and Zustand implementations. The system is designed to be type-safe, maintainable, and easy to use while providing the flexibility to choose the state management solution that best fits your needs.

## Key Features

- ðŸ”„ Switchable implementations (Context API â†” Zustand)
- ðŸ”’ Type-safe authentication state
- ðŸ“¦ Zero-config default implementation
- ðŸ›  CLI tool for switching implementations
- ðŸ’¾ Persistent state (with Zustand implementation)
- ðŸŽ£ Consistent hook-based API

## Default Implementation

By default, the project uses React's Context API for authentication state management. This choice provides:

- Zero additional dependencies
- Built-in React features
- Simpler debugging
- Smaller bundle size

```tsx
import { useUser } from '@/state/auth'

function MyComponent() {
  const { user, isLoading, logout } = useUser()
  // ... use auth state
}
```

## Available Implementations

### Context API (`src/state/auth/context.tsx`)

The Context-based implementation uses React's built-in features:

```tsx
const { user, isLoading, error, logout } = useUser()
```

**Pros:**
- No extra dependencies
- Built-in React feature
- Simpler debugging
- Smaller bundle size

**Cons:**
- No built-in persistence
- Potential prop-drilling in complex apps
- Performance might be affected in large apps

### Zustand (`src/state/auth/zustand.ts`)

The Zustand implementation provides additional features:

```tsx
const { user, isLoading, error, logout } = useUser()
```

**Pros:**
- Built-in persistence
- Better performance for complex state
- DevTools integration
- Simpler global state management

**Cons:**
- Additional dependency
- Slightly larger bundle size
- More complex debugging

## Switching Between Implementations

### Using the CLI Tool

```bash
# Switch to Zustand
./scripts/switch-auth.sh zustand

# Switch back to Context API
./scripts/switch-auth.sh context

# Check current implementation
./scripts/switch-auth.sh check

# Interactive menu
./scripts/switch-auth.sh interactive
```

### What Happens During Switch

When switching to Zustand:
1. Installs the zustand package
2. Creates `zustand.ts` implementation file
3. Updates exports to use Zustand

When switching to Context:
1. Removes the zustand package
2. Removes `zustand.ts` file
3. Updates exports to use Context API

## Type System

The type system is shared between implementations:

```tsx
type User = {
  id: string
  email: string
  firstName: string
  lastName: string
  name?: string
  image?: string | null
  provider?: string
}

type AuthState = {
  user: User | null
  isLoading: boolean
  error: AuthError | null
}

type AuthActions = {
  setUser: (user: User | null) => void
  clearError: () => void
  logout: () => Promise<void>
  refreshUser: () => Promise<void>
}

type AuthContextType = AuthState & AuthActions
```

## Best Practices

### When to Use Context API

- Smaller applications
- Simple authentication needs
- When minimizing dependencies is crucial
- During prototyping phases

### When to Use Zustand

- Larger applications
- Complex state requirements
- When persistence is needed
- When performance is crucial

### Implementation Guidelines

1. Always use the `useUser` hook from `@/state/auth`
2. Never import directly from `context.tsx` or `zustand.ts`
3. Handle loading and error states appropriately
4. Use TypeScript for type safety

## Example Usage

```tsx
'use client'

import { useUser } from '@/state/auth'

export default function AuthenticatedComponent() {
  const { user, isLoading, error, logout } = useUser()

  if (isLoading) {
    return <LoadingSpinner />
  }

  if (error) {
    return <ErrorMessage error={error} />
  }

  if (!user) {
    return <LoginPrompt />
  }

  return (
    <div>
      <h1>Welcome, {user.firstName}!</h1>
      <button onClick={logout}>Logout</button>
    </div>
  )
}
```

## Error Handling

Both implementations provide consistent error handling:

```tsx
const { error, clearError } = useUser()

if (error) {
  return (
    <div>
      <p>Error: {error.message}</p>
      <button onClick={clearError}>Dismiss</button>
    </div>
  )
}
```

## Contributing

When modifying the auth system:

1. Ensure changes are reflected in both implementations
2. Update types in `src/core/types/auth.ts`
3. Maintain consistent API between implementations
4. Add appropriate JSDoc comments
5. Update tests if applicable

## Why This Approach?

This flexible approach provides several benefits:

1. **Adaptability**: Easy to switch as your app's needs grow
2. **Type Safety**: Shared types ensure consistency
3. **Developer Experience**: Consistent API regardless of implementation
4. **Performance**: Choose the best tool for your scale
5. **Maintenance**: Clean separation of concerns

The system is designed to grow with your application while maintaining a consistent developer experience. 
