# Complete Guide to Prisma

## Table of Contents
- [Setup](#setup)
- [Basic Queries](#basic-queries)
- [Mutations](#mutations)
- [Relations](#relations)
- [Reusable CRUD Operations](#reusable-crud)
- [Real World Example: Registration Flow](#registration-flow)

## Setup

### 1. Installation
```bash
npm install @prisma/client
npm install prisma --save-dev
```

### 2. Initialize Prisma
```bash
npx prisma init
```

### 3. Database Schema
Here's our example schema:
```prisma
model User {
  id        String    @id @default(cuid())
  email     String    @unique
  password  String?
  firstName String?
  lastName  String?
  name      String?
  role      String    @default("USER")
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  posts     Post[]
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### 4. Generate Client
After any schema changes:
```bash
npx prisma generate
```

## Basic Queries 

### Setting up the client
```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

### Finding Records

```typescript
// Find a single user
const user = await prisma.user.findUnique({
  where: {
    email: 'john@example.com'
  }
})

// Find many users
const users = await prisma.user.findMany({
  where: {
    role: 'USER'
  }
})

// Find with select
const userNames = await prisma.user.findMany({
  select: {
    firstName: true,
    lastName: true
  }
})

// Find with relations
const userWithPosts = await prisma.user.findUnique({
  where: {
    id: 'user_id'
  },
  include: {
    posts: true
  }
})

// Complex filters
const filteredUsers = await prisma.user.findMany({
  where: {
    OR: [
      { role: 'ADMIN' },
      { email: { contains: '@company.com' } }
    ],
    AND: {
      createdAt: {
        gte: new Date('2023-01-01')
      }
    }
  }
})
```

## Mutations {#mutations}

### Creating Records

```typescript
// Create a user
const newUser = await prisma.user.create({
  data: {
    email: 'john@example.com',
    firstName: 'John',
    lastName: 'Doe'
  }
})

// Create user with related posts
const userWithPosts = await prisma.user.create({
  data: {
    email: 'jane@example.com',
    firstName: 'Jane',
    posts: {
      create: [
        { title: 'My first post', content: 'Hello world!' },
        { title: 'Another post', content: 'More content' }
      ]
    }
  },
  include: {
    posts: true
  }
})
```

### Updating Records

```typescript
// Update a single record
const updatedUser = await prisma.user.update({
  where: {
    id: 'user_id'
  },
  data: {
    role: 'ADMIN'
  }
})

// Update many records
const updateManyResult = await prisma.post.updateMany({
  where: {
    authorId: 'user_id'
  },
  data: {
    published: true
  }
})
```

### Deleting Records

```typescript
// Delete a single record
const deletedUser = await prisma.user.delete({
  where: {
    id: 'user_id'
  }
})

// Delete many records
const deleteManyResult = await prisma.post.deleteMany({
  where: {
    published: false
  }
})
```

## Relations {#relations}

### Working with Related Records

```typescript
// Find users and their posts
const usersAndPosts = await prisma.user.findMany({
  include: {
    posts: {
      where: {
        published: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    }
  }
})

// Nested writes
const newUserWithPost = await prisma.user.create({
  data: {
    email: 'bob@example.com',
    posts: {
      create: {
        title: 'My first post'
      }
    }
  }
})
```

## Reusable CRUD Operations {#reusable-crud}

Here's a reusable CRUD class that can be used for any entity:

```typescript
// lib/crud.ts
import { PrismaClient } from '@prisma/client'

export class CrudService<T> {
  constructor(
    private readonly prisma: PrismaClient,
    private readonly model: any
  ) {}

  async findMany(params: {
    where?: any
    orderBy?: any
    include?: any
    select?: any
    skip?: number
    take?: number
  }) {
    return this.model.findMany(params)
  }

  async findUnique(params: { where: any; include?: any }) {
    return this.model.findUnique(params)
  }

  async create(params: { data: any; include?: any }) {
    return this.model.create(params)
  }

  async update(params: { where: any; data: any; include?: any }) {
    return this.model.update(params)
  }

  async delete(params: { where: any }) {
    return this.model.delete(params)
  }

  async count(params: { where?: any }) {
    return this.model.count(params)
  }
}

// Example usage:
// services/user.service.ts
import { prisma } from '@/lib/prisma'
import { CrudService } from '@/lib/crud'

export class UserService extends CrudService<typeof prisma.user> {
  constructor() {
    super(prisma, prisma.user)
  }

  // Add custom methods specific to users
  async findByEmail(email: string) {
    return this.findUnique({
      where: { email }
    })
  }

  async createWithPosts(data: any) {
    return this.create({
      data,
      include: { posts: true }
    })
  }
}

// Using the service:
const userService = new UserService()

// Find users
const users = await userService.findMany({
  where: { role: 'USER' }
})

// Create user
const newUser = await userService.create({
  data: {
    email: 'test@example.com',
    firstName: 'Test'
  }
})

// Custom method
const userByEmail = await userService.findByEmail('test@example.com')
```

## Real World Example: Registration Flow

Let's walk through our actual registration implementation, from UI to database:

### 1. Project Structure
```
src/
├── app/
│   └── (auth)/
│       └── register/
│           ├── page.tsx        # Registration page UI
│           └── actions.ts      # Server actions
├── lib/
│   ├── prisma.ts              # Prisma client
│   └── auth.ts                # Auth utilities
└── components/
    └── auth/
        └── register-form.tsx   # Form component
```

### 2. Registration Form Component
```typescript
// components/auth/register-form.tsx
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { registerSchema } from '@/lib/validations/auth'
import type { RegisterInput } from '@/lib/validations/auth'

export function RegisterForm() {
  const [isPending, setIsPending] = useState(false)
  const form = useForm<RegisterInput>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      email: '',
      password: '',
      firstName: '',
      lastName: ''
    }
  })

  async function onSubmit(data: RegisterInput) {
    setIsPending(true)
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      
      if (!response.ok) throw new Error('Registration failed')
      
      // Handle success (e.g., redirect to login)
    } catch (error) {
      console.error('Registration error:', error)
      // Handle error (show toast, etc.)
    } finally {
      setIsPending(false)
    }
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
      <Input
        label="Email"
        {...form.register('email')}
        error={form.formState.errors.email?.message}
      />
      <Input
        label="Password"
        type="password"
        {...form.register('password')}
        error={form.formState.errors.password?.message}
      />
      <Input
        label="First Name"
        {...form.register('firstName')}
        error={form.formState.errors.firstName?.message}
      />
      <Input
        label="Last Name"
        {...form.register('lastName')}
        error={form.formState.errors.lastName?.message}
      />
      <Button type="submit" disabled={isPending}>
        {isPending ? 'Registering...' : 'Register'}
      </Button>
    </form>
  )
}
```

### 3. Server Action
```typescript
// app/(auth)/register/actions.ts
'use server'

import { hash } from 'bcryptjs'
import { prisma } from '@/lib/prisma'
import { registerSchema } from '@/lib/validations/auth'
import type { RegisterInput } from '@/lib/validations/auth'

export async function register(data: RegisterInput) {
  // 1. Validate input
  const validatedFields = registerSchema.safeParse(data)
  if (!validatedFields.success) {
    throw new Error('Invalid input')
  }

  // 2. Check if user exists
  const existingUser = await prisma.user.findUnique({
    where: { email: data.email }
  })

  if (existingUser) {
    throw new Error('User already exists')
  }

  // 3. Hash password
  const hashedPassword = await hash(data.password, 12)

  // 4. Create user with Prisma transaction
  try {
    const user = await prisma.$transaction(async (tx) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: data.email,
          password: hashedPassword,
          firstName: data.firstName,
          lastName: data.lastName,
          role: data.email === process.env.ADMIN_EMAIL ? 'ADMIN' : 'USER'
        }
      })

      // Create initial session
      await tx.session.create({
        data: {
          userId: user.id,
          expires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
          sessionToken: crypto.randomUUID()
        }
      })

      return user
    })

    return { success: true, user }
  } catch (error) {
    console.error('Registration error:', error)
    throw new Error('Failed to create user')
  }
}
```

### 4. API Route (Alternative to Server Action)
```typescript
// app/api/auth/register/route.ts
import { NextResponse } from 'next/server'
import { register } from '@/app/(auth)/register/actions'
import type { RegisterInput } from '@/lib/validations/auth'

export async function POST(req: Request) {
  try {
    const data = (await req.json()) as RegisterInput
    const result = await register(data)
    return NextResponse.json(result)
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 400 }
    )
  }
}
```

### 5. Validation Schema
```typescript
// lib/validations/auth.ts
import { z } from 'zod'

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'Password must contain uppercase, lowercase and number'
    ),
  firstName: z.string().min(2, 'First name is required'),
  lastName: z.string().min(2, 'Last name is required')
})

export type RegisterInput = z.infer<typeof registerSchema>
```

### 6. Error Handling Utilities
```typescript
// lib/utils/api-error.ts
export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number = 400,
    public code?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export function handlePrismaError(error: any): never {
  if (error.code === 'P2002') {
    throw new ApiError('Email already exists', 400, 'EMAIL_EXISTS')
  }
  
  throw new ApiError('Database error', 500)
}
```

### Flow Explanation

1. **UI Layer (`register/page.tsx`)**
   - Contains the registration form
   - Handles form state and validation
   - Provides user feedback
   - Located in auth group for route grouping

2. **Form Handling**
   - Uses `react-hook-form` for form state
   - `zod` for validation
   - Client-side validation before submission

3. **Server Action**
   - Validates input server-side
   - Checks for existing users
   - Hashes password
   - Creates user in database
   - Uses transaction for atomic operations

4. **Database Operation**
   - Creates user record
   - Creates session in same transaction
   - Handles role assignment
   - Returns created user

5. **Error Handling**
   - Client-side validation errors
   - Server-side validation
   - Database errors
   - Custom error types

6. **Security Considerations**
   - Password hashing
   - Input validation
   - Error handling
   - Session management

Remember to:
- Always validate input on both client and server
- Use transactions for related operations
- Handle errors appropriately
- Keep sensitive operations server-side
- Use proper TypeScript types
- Implement proper session management
